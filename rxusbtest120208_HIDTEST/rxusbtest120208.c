/***********************************************************************/
/*                                                                     */
/*  FILE        :rxusbtest120208.c                                     */
/*  DATE        :Wed, Feb 08, 2012                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :RX62N                                                 */
/*                                                                     */
/*  This file is generated by KPIT GNU Project Generator.              */
/*                                                                     */
/***********************************************************************/
                    
#include "iodefine.h"


#include "DEBUGFIFO.h"


#ifdef CPPAPP
//Initialize global constructors
// The GNURX uses a different method to initialize global constructors
// The below call is not invoked in case of RX target
extern "C" void __main()
{
  static int initialized;
  if (! initialized)
    {
      typedef void (*pfunc) ();
      extern pfunc __ctors[];
      extern pfunc __ctors_end[];
      pfunc *p;

      initialized = 1;
      for (p = __ctors_end; p > __ctors; )
	(*--p) ();

    }
}
#endif 



void SetDefaultInterrupts(void)
{
	/*Enable VBSE (VBUS) Interrupt*/
	USB0.INTENB0.BIT.VBSE = 1;
	
	/*Enable DVST (Device State Transition) Interrupt*/
	USB0.INTENB0.BIT.DVSE = 1;
	
	/*Enable CTRT (Control Transfer Stage Transition) Interrupt*/
	USB0.INTENB0.BIT.CTRE = 1;
	
	/*Enable BEMP - see particular pipe BEMP enable aswell*/
	USB0.INTENB0.BIT.BEMPE = 1;
	
	/*Enable BRDY - see particular pipe BRDY enable aswell*/
	USB0.INTENB0.BIT.BRDYE = 1;
	
	/***Pipe specific***/
	
	/*Contol pipe*/
	/*BEMP: used to continue sending data (or moving on to status stage)
	during CONTROL IN DATA*/
	USB0.BEMPENB.BIT.PIPE0BEMPE = 1;
	
	/*BRDY used for Control OUT = enabled when required*/
	USB0.BRDYENB.BIT.PIPE0BRDYE = 0;
	
	/*Bulk OUT pipe (pipe1)*/
	/*BEMP - enable only as required*/
	USB0.BEMPENB.BIT.PIPE1BEMPE = 0;
	
	/*BRDY - enable so host can always send us data*/
	USB0.BRDYENB.BIT.PIPE1BRDYE = 0;
}




void HW_Init(void)
{
	volatile unsigned long Delay;

	/*Set Port P23(USB0DPUPE-A) as Input direction*/
	/*NOTE: Document "USB_RSK+RX62N_Jumper_DIP-SW" stated this.*/
	//PORT2.DDR.BIT.B3 = 0;
	
	/*Enable input buffer for USB0_VBUS pin*/
	PORT1.ICR.BIT.B6 = 1;
	
	/*Pin Function Select*/
	/*USB0 pins enable*/
	IOPORT.PFKUSB.BIT.USBE = 1;
	
	/*Select fuction mode for USB0 pins*/
	IOPORT.PFKUSB.BIT.USBMD = 0;
	
	/*Enable USB interrupts at high level*/
	ICU.IER[0x04].BIT.IEN6 = 1;
	
	/*Set interrupt priority*/
	ICU.IPR[0x0E].BIT.IPR = 15;
	
	/*Cancel USB Module stop state.*/
	MSTP_USB0 = 0;
	
	
	/*Start USB clock*/
	USB0.SYSCFG.BIT.SCKE = 1;
	
	/*Enable USB operation*/
	USB0.SYSCFG.BIT.USBE = 1;
	
	/*Select Function not Host*/
	USB0.SYSCFG.BIT.DCFM = 0;
	
	/*Enable D+ pull up*/
	USB0.SYSCFG.BIT.DPRPU = 1;
	
	/*Configire Pipes/Endpoints */
	//ConfigurePipes();

	/* Enable specific USB interrupts */
	SetDefaultInterrupts();
}


//
// Clock configuration.
//
void clockConfiguration()
{
	// Clock configuration.
	SYSTEM.SCKCR.BIT.ICK = 0x00; // ICK = 96MHz.
	SYSTEM.SCKCR.BIT.PCK = 0x01; // PCK = 48MHz.
}

//
// Enable modules.
//
void moduleEnable()
{
	// Release USB0, SCI1 module stop.
	SYSTEM.MSTPCRB.BIT.MSTPB19 = 0; // USB0.
}

void portSetup()
{
	// P23 is LED out.	
	PORT2.DDR.BIT.B3 = 1;
	
	// 
	// USB0_DP, USB0_DM: Enable.
	// P16: USB0_VBUS.
	// P14: USB0_DPUPE-B.
	//
	IOPORT.PFKUSB.BYTE = 0x14; // USBE = 1, PDHZS = 0, PUPHZS = 1, USBMD[1:0] = 2'b00(Function mode). 
	PORT1.ICR.BIT.B6 = 1;
}


//
// USB setup.
//


void usbModuleSetup(void)
{	
	/* SCLK Enable */
	USB0.SYSCFG.BIT.SCKE = 1;
	
	/* USB Reset */
	USB0.SYSCFG.BIT.USBE = 0;

	/* USB Enable */
	USB0.SYSCFG.BIT.USBE = 1;

	// PHY0 Enable.
	USB.DPUSR0R.BIT.FIXPHY0 = 0;
}


void usbPipeSetup(void)
{
	/*** BULK IN ***/
	{
		/*Select Pipe*/
		USB0.PIPESEL.BIT.PIPESEL = 1;
	
		/*Pipe Control*/
		/*Note: PID must be set to NAK before configuring PIPECFG*/
		USB0.PIPE1CTR.WORD = 0x000;
		
		/*Wait for pipe to be not busy*/
		while(USB0.PIPE1CTR.BIT.PBUSY == 1);
	
		/*Pipe Configure, Direction, Type, Double Buffer, BRDY Interrupt operation*/
		/*Default */
		USB0.PIPECFG.WORD = 0;
		
		/*Endpoint*/
		USB0.PIPECFG.BIT.EPNUM = 1;
		
		/*Direction*/
		USB0.PIPECFG.BIT.DIR = 1;
		
		/*Double Buffer */
		USB0.PIPECFG.BIT.DBLB = 1;
		
		/*BRDY Interrupt Operation*/
		USB0.PIPECFG.BIT.BFRE = 0;
		
		/*Transfer Type */
		USB0.PIPECFG.BIT.TYPE = 1;
	
		/*Pipe Packet Size*/
		USB0.PIPEMAXP.BIT.MXPS = 64;
	}

	/*Un-select any pipe*/
	USB0.PIPESEL.BIT.PIPESEL = 0;	
}

	
void usbInterruptSetup(void)
{
	/* CFIFO Port Select Register  (0x1E) */
	//USB_WR(CFIFOSEL,  USB_CFIFO_MBW);

	/* D0FIFO Port Select Register (0x24) */
	//USB_WR(D0FIFOSEL, USB_D0FIFO_MBW);

	/* D1FIFO Port Select Register (0x2A) */
	//USB_WR(D1FIFOSEL, USB_D1FIFO_MBW);

	/* BIGENDIAN -> BIGEND=1 */
	//USB_MDF_PAT(CFIFOSEL,  USB_FIFOENDIAN, USBC_BIGEND);

	/* BIGENDIAN -> BIGEND=1 */
	//USB_MDF_PAT(D0FIFOSEL, USB_FIFOENDIAN, USBC_BIGEND);

	/* BIGENDIAN -> BIGEND=1 */
	//USB_MDF_PAT(D1FIFOSEL, USB_FIFOENDIAN, USBC_BIGEND);
	
	USB0.INTENB0.WORD = 0x9f00;
	USB0.BRDYENB.WORD = 0x03ff;
	//USB0.NRDYENB.WORD = 0x03ff;
	USB0.BEMPENB.WORD = 0x03ff;
	
	/*Enable VBSE (VBUS) Interrupt*/
	//USB0.INTENB0.BIT.VBSE = 1;
	
	/*Enable DVST (Device State Transition) Interrupt*/
	//USB0.INTENB0.BIT.DVSE = 1;
	
	/*Enable CTRT (Control Transfer Stage Transition) Interrupt*/
	//USB0.INTENB0.BIT.CTRE = 1;
	
	/*Enable BEMP - see particular pipe BEMP enable aswell*/
	//USB0.INTENB0.BIT.BEMPE = 1;
	
	/*Enable BRDY - see particular pipe BRDY enable aswell*/
	//USB0.INTENB0.BIT.BRDYE = 1;
	
	/***Pipe specific***/
	
	/*Contol pipe*/
	/*BEMP: used to continue sending data (or moving on to status stage)
	during CONTROL IN DATA*/
	USB0.BEMPENB.BIT.PIPE0BEMPE = 1;
	
	/*BRDY used for Control OUT = enabled when required*/
	USB0.BRDYENB.BIT.PIPE0BRDYE = 0;
	
	/*Bulk IN pipe (pipe1)*/
	/*BEMP - enable only as required*/
	USB0.BEMPENB.BIT.PIPE1BEMPE = 0;
	
	/*BRDY - enable so host can always send us data*/
	USB0.BRDYENB.BIT.PIPE1BRDYE = 0;
}


void irqConfiguration()
{
	// USB.
	ICU.IER[0x04].BIT.IEN6 = 1;   // USB0 Interrupt enable.
	ICU.IPR[0x0e].BIT.IPR = 0x0f; // USB0 IRQ priority highest.
	
	ICU.IER[0x04].BIT.IEN4 = 1;   // USB0 Interrupt enable.
	ICU.IPR[0x0c].BIT.IPR = 0x0f; // USB0 IRQ priority highest.
	
	// NMI
	ICU.NMIER.BIT.NMIEN = 1;
}


//
// LED Control.
//
void ledOn()
{
    PORT2.DR.BIT.B3 = 1;	
}

void ledOff()
{
    PORT2.DR.BIT.B3 = 0;	
}

//
//
//
int main(void)
{
	// Configurations.
	clockConfiguration();
	moduleEnable();
	
	// Port.
	portSetup();
	
	// USB.
	usbModuleSetup();
	usbPipeSetup();
	usbInterruptSetup();
	
	// 
	irqConfiguration();
	
    
	DEBUGFIFO_Init();


	//HW_Init();


	// TODO: add application code here
	DEBUGFIFO_OutLine("============================");
	DEBUGFIFO_OutLine("=== RX62 USB TEST Start! ===");
	DEBUGFIFO_OutLine("============================");
	DEBUGFIFO_OutLine("");

    while (1) {
		// Do nothing.
    }
  return 0;
}
